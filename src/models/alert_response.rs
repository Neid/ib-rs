/* 
 * Client Portal Web API
 *
 * Client Poral Web API
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct AlertResponse {
  /// account id
  #[serde(rename = "account")]
  account: Option<String>,
  /// whether alert is active or not, so value can only be 0 or 1
  #[serde(rename = "alert_active")]
  alert_active: Option<i32>,
  /// MTA alert only
  #[serde(rename = "alert_default_type")]
  alert_default_type: Option<String>,
  /// email address to receive alert
  #[serde(rename = "alert_email")]
  alert_email: Option<String>,
  /// The message you want to receive via email or text message
  #[serde(rename = "alert_message")]
  alert_message: Option<String>,
  /// MTA alert only
  #[serde(rename = "alert_mta_currency")]
  alert_mta_currency: Option<String>,
  /// MTA alert only
  #[serde(rename = "alert_mta_defaults")]
  alert_mta_defaults: Option<String>,
  /// name of alert
  #[serde(rename = "alert_name")]
  alert_name: Option<String>,
  /// audio message to play when alert is triggered
  #[serde(rename = "alert_play_audio")]
  alert_play_audio: Option<String>,
  /// whether alert is repeatable or not, so value can only be 0 or 1
  #[serde(rename = "alert_repeatable")]
  alert_repeatable: Option<i32>,
  /// whether allowing to send email or not, so value can only be 0 or 1, 
  #[serde(rename = "alert_send_message")]
  alert_send_message: Option<i32>,
  /// value can only be 0 or 1, set to 1 to allow to show alert in pop-ups
  #[serde(rename = "alert_show_popup")]
  alert_show_popup: Option<i32>,
  /// whether the alert has been triggered
  #[serde(rename = "alert_triggered")]
  alert_triggered: Option<bool>,
  /// whether allowing the condition can be triggered outside of regular trading hours, 1 means allow
  #[serde(rename = "condition_outside_rth")]
  condition_outside_rth: Option<i32>,
  /// size of conditions array
  #[serde(rename = "condition_size")]
  condition_size: Option<i32>,
  #[serde(rename = "conditions")]
  conditions: Option<Vec<::models::AlertresponseConditions>>,
  /// format, YYYYMMDD-HH:mm:ss 
  #[serde(rename = "expire_time")]
  expire_time: Option<String>,
  /// value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile 
  #[serde(rename = "itws_orders_only")]
  itws_orders_only: Option<i32>,
  #[serde(rename = "order_id")]
  order_id: Option<i32>,
  /// whether the alert can be edited
  #[serde(rename = "order_not_editable")]
  order_not_editable: Option<bool>,
  /// status of alert
  #[serde(rename = "order_status")]
  order_status: Option<String>,
  /// value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours. 
  #[serde(rename = "outsideRth")]
  outside_rth: Option<i32>,
  /// time in force, can only be GTC or GTD
  #[serde(rename = "tif")]
  tif: Option<String>,
  /// MTA alert only
  #[serde(rename = "time_zone")]
  time_zone: Option<String>,
  /// for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert 
  #[serde(rename = "tool_id")]
  tool_id: Option<i32>
}

impl AlertResponse {
  pub fn new() -> AlertResponse {
    AlertResponse {
      account: None,
      alert_active: None,
      alert_default_type: None,
      alert_email: None,
      alert_message: None,
      alert_mta_currency: None,
      alert_mta_defaults: None,
      alert_name: None,
      alert_play_audio: None,
      alert_repeatable: None,
      alert_send_message: None,
      alert_show_popup: None,
      alert_triggered: None,
      condition_outside_rth: None,
      condition_size: None,
      conditions: None,
      expire_time: None,
      itws_orders_only: None,
      order_id: None,
      order_not_editable: None,
      order_status: None,
      outside_rth: None,
      tif: None,
      time_zone: None,
      tool_id: None
    }
  }

  pub fn set_account(&mut self, account: String) {
    self.account = Some(account);
  }

  pub fn with_account(mut self, account: String) -> AlertResponse {
    self.account = Some(account);
    self
  }

  pub fn account(&self) -> Option<&String> {
    self.account.as_ref()
  }

  pub fn reset_account(&mut self) {
    self.account = None;
  }

  pub fn set_alert_active(&mut self, alert_active: i32) {
    self.alert_active = Some(alert_active);
  }

  pub fn with_alert_active(mut self, alert_active: i32) -> AlertResponse {
    self.alert_active = Some(alert_active);
    self
  }

  pub fn alert_active(&self) -> Option<&i32> {
    self.alert_active.as_ref()
  }

  pub fn reset_alert_active(&mut self) {
    self.alert_active = None;
  }

  pub fn set_alert_default_type(&mut self, alert_default_type: String) {
    self.alert_default_type = Some(alert_default_type);
  }

  pub fn with_alert_default_type(mut self, alert_default_type: String) -> AlertResponse {
    self.alert_default_type = Some(alert_default_type);
    self
  }

  pub fn alert_default_type(&self) -> Option<&String> {
    self.alert_default_type.as_ref()
  }

  pub fn reset_alert_default_type(&mut self) {
    self.alert_default_type = None;
  }

  pub fn set_alert_email(&mut self, alert_email: String) {
    self.alert_email = Some(alert_email);
  }

  pub fn with_alert_email(mut self, alert_email: String) -> AlertResponse {
    self.alert_email = Some(alert_email);
    self
  }

  pub fn alert_email(&self) -> Option<&String> {
    self.alert_email.as_ref()
  }

  pub fn reset_alert_email(&mut self) {
    self.alert_email = None;
  }

  pub fn set_alert_message(&mut self, alert_message: String) {
    self.alert_message = Some(alert_message);
  }

  pub fn with_alert_message(mut self, alert_message: String) -> AlertResponse {
    self.alert_message = Some(alert_message);
    self
  }

  pub fn alert_message(&self) -> Option<&String> {
    self.alert_message.as_ref()
  }

  pub fn reset_alert_message(&mut self) {
    self.alert_message = None;
  }

  pub fn set_alert_mta_currency(&mut self, alert_mta_currency: String) {
    self.alert_mta_currency = Some(alert_mta_currency);
  }

  pub fn with_alert_mta_currency(mut self, alert_mta_currency: String) -> AlertResponse {
    self.alert_mta_currency = Some(alert_mta_currency);
    self
  }

  pub fn alert_mta_currency(&self) -> Option<&String> {
    self.alert_mta_currency.as_ref()
  }

  pub fn reset_alert_mta_currency(&mut self) {
    self.alert_mta_currency = None;
  }

  pub fn set_alert_mta_defaults(&mut self, alert_mta_defaults: String) {
    self.alert_mta_defaults = Some(alert_mta_defaults);
  }

  pub fn with_alert_mta_defaults(mut self, alert_mta_defaults: String) -> AlertResponse {
    self.alert_mta_defaults = Some(alert_mta_defaults);
    self
  }

  pub fn alert_mta_defaults(&self) -> Option<&String> {
    self.alert_mta_defaults.as_ref()
  }

  pub fn reset_alert_mta_defaults(&mut self) {
    self.alert_mta_defaults = None;
  }

  pub fn set_alert_name(&mut self, alert_name: String) {
    self.alert_name = Some(alert_name);
  }

  pub fn with_alert_name(mut self, alert_name: String) -> AlertResponse {
    self.alert_name = Some(alert_name);
    self
  }

  pub fn alert_name(&self) -> Option<&String> {
    self.alert_name.as_ref()
  }

  pub fn reset_alert_name(&mut self) {
    self.alert_name = None;
  }

  pub fn set_alert_play_audio(&mut self, alert_play_audio: String) {
    self.alert_play_audio = Some(alert_play_audio);
  }

  pub fn with_alert_play_audio(mut self, alert_play_audio: String) -> AlertResponse {
    self.alert_play_audio = Some(alert_play_audio);
    self
  }

  pub fn alert_play_audio(&self) -> Option<&String> {
    self.alert_play_audio.as_ref()
  }

  pub fn reset_alert_play_audio(&mut self) {
    self.alert_play_audio = None;
  }

  pub fn set_alert_repeatable(&mut self, alert_repeatable: i32) {
    self.alert_repeatable = Some(alert_repeatable);
  }

  pub fn with_alert_repeatable(mut self, alert_repeatable: i32) -> AlertResponse {
    self.alert_repeatable = Some(alert_repeatable);
    self
  }

  pub fn alert_repeatable(&self) -> Option<&i32> {
    self.alert_repeatable.as_ref()
  }

  pub fn reset_alert_repeatable(&mut self) {
    self.alert_repeatable = None;
  }

  pub fn set_alert_send_message(&mut self, alert_send_message: i32) {
    self.alert_send_message = Some(alert_send_message);
  }

  pub fn with_alert_send_message(mut self, alert_send_message: i32) -> AlertResponse {
    self.alert_send_message = Some(alert_send_message);
    self
  }

  pub fn alert_send_message(&self) -> Option<&i32> {
    self.alert_send_message.as_ref()
  }

  pub fn reset_alert_send_message(&mut self) {
    self.alert_send_message = None;
  }

  pub fn set_alert_show_popup(&mut self, alert_show_popup: i32) {
    self.alert_show_popup = Some(alert_show_popup);
  }

  pub fn with_alert_show_popup(mut self, alert_show_popup: i32) -> AlertResponse {
    self.alert_show_popup = Some(alert_show_popup);
    self
  }

  pub fn alert_show_popup(&self) -> Option<&i32> {
    self.alert_show_popup.as_ref()
  }

  pub fn reset_alert_show_popup(&mut self) {
    self.alert_show_popup = None;
  }

  pub fn set_alert_triggered(&mut self, alert_triggered: bool) {
    self.alert_triggered = Some(alert_triggered);
  }

  pub fn with_alert_triggered(mut self, alert_triggered: bool) -> AlertResponse {
    self.alert_triggered = Some(alert_triggered);
    self
  }

  pub fn alert_triggered(&self) -> Option<&bool> {
    self.alert_triggered.as_ref()
  }

  pub fn reset_alert_triggered(&mut self) {
    self.alert_triggered = None;
  }

  pub fn set_condition_outside_rth(&mut self, condition_outside_rth: i32) {
    self.condition_outside_rth = Some(condition_outside_rth);
  }

  pub fn with_condition_outside_rth(mut self, condition_outside_rth: i32) -> AlertResponse {
    self.condition_outside_rth = Some(condition_outside_rth);
    self
  }

  pub fn condition_outside_rth(&self) -> Option<&i32> {
    self.condition_outside_rth.as_ref()
  }

  pub fn reset_condition_outside_rth(&mut self) {
    self.condition_outside_rth = None;
  }

  pub fn set_condition_size(&mut self, condition_size: i32) {
    self.condition_size = Some(condition_size);
  }

  pub fn with_condition_size(mut self, condition_size: i32) -> AlertResponse {
    self.condition_size = Some(condition_size);
    self
  }

  pub fn condition_size(&self) -> Option<&i32> {
    self.condition_size.as_ref()
  }

  pub fn reset_condition_size(&mut self) {
    self.condition_size = None;
  }

  pub fn set_conditions(&mut self, conditions: Vec<::models::AlertresponseConditions>) {
    self.conditions = Some(conditions);
  }

  pub fn with_conditions(mut self, conditions: Vec<::models::AlertresponseConditions>) -> AlertResponse {
    self.conditions = Some(conditions);
    self
  }

  pub fn conditions(&self) -> Option<&Vec<::models::AlertresponseConditions>> {
    self.conditions.as_ref()
  }

  pub fn reset_conditions(&mut self) {
    self.conditions = None;
  }

  pub fn set_expire_time(&mut self, expire_time: String) {
    self.expire_time = Some(expire_time);
  }

  pub fn with_expire_time(mut self, expire_time: String) -> AlertResponse {
    self.expire_time = Some(expire_time);
    self
  }

  pub fn expire_time(&self) -> Option<&String> {
    self.expire_time.as_ref()
  }

  pub fn reset_expire_time(&mut self) {
    self.expire_time = None;
  }

  pub fn set_itws_orders_only(&mut self, itws_orders_only: i32) {
    self.itws_orders_only = Some(itws_orders_only);
  }

  pub fn with_itws_orders_only(mut self, itws_orders_only: i32) -> AlertResponse {
    self.itws_orders_only = Some(itws_orders_only);
    self
  }

  pub fn itws_orders_only(&self) -> Option<&i32> {
    self.itws_orders_only.as_ref()
  }

  pub fn reset_itws_orders_only(&mut self) {
    self.itws_orders_only = None;
  }

  pub fn set_order_id(&mut self, order_id: i32) {
    self.order_id = Some(order_id);
  }

  pub fn with_order_id(mut self, order_id: i32) -> AlertResponse {
    self.order_id = Some(order_id);
    self
  }

  pub fn order_id(&self) -> Option<&i32> {
    self.order_id.as_ref()
  }

  pub fn reset_order_id(&mut self) {
    self.order_id = None;
  }

  pub fn set_order_not_editable(&mut self, order_not_editable: bool) {
    self.order_not_editable = Some(order_not_editable);
  }

  pub fn with_order_not_editable(mut self, order_not_editable: bool) -> AlertResponse {
    self.order_not_editable = Some(order_not_editable);
    self
  }

  pub fn order_not_editable(&self) -> Option<&bool> {
    self.order_not_editable.as_ref()
  }

  pub fn reset_order_not_editable(&mut self) {
    self.order_not_editable = None;
  }

  pub fn set_order_status(&mut self, order_status: String) {
    self.order_status = Some(order_status);
  }

  pub fn with_order_status(mut self, order_status: String) -> AlertResponse {
    self.order_status = Some(order_status);
    self
  }

  pub fn order_status(&self) -> Option<&String> {
    self.order_status.as_ref()
  }

  pub fn reset_order_status(&mut self) {
    self.order_status = None;
  }

  pub fn set_outside_rth(&mut self, outside_rth: i32) {
    self.outside_rth = Some(outside_rth);
  }

  pub fn with_outside_rth(mut self, outside_rth: i32) -> AlertResponse {
    self.outside_rth = Some(outside_rth);
    self
  }

  pub fn outside_rth(&self) -> Option<&i32> {
    self.outside_rth.as_ref()
  }

  pub fn reset_outside_rth(&mut self) {
    self.outside_rth = None;
  }

  pub fn set_tif(&mut self, tif: String) {
    self.tif = Some(tif);
  }

  pub fn with_tif(mut self, tif: String) -> AlertResponse {
    self.tif = Some(tif);
    self
  }

  pub fn tif(&self) -> Option<&String> {
    self.tif.as_ref()
  }

  pub fn reset_tif(&mut self) {
    self.tif = None;
  }

  pub fn set_time_zone(&mut self, time_zone: String) {
    self.time_zone = Some(time_zone);
  }

  pub fn with_time_zone(mut self, time_zone: String) -> AlertResponse {
    self.time_zone = Some(time_zone);
    self
  }

  pub fn time_zone(&self) -> Option<&String> {
    self.time_zone.as_ref()
  }

  pub fn reset_time_zone(&mut self) {
    self.time_zone = None;
  }

  pub fn set_tool_id(&mut self, tool_id: i32) {
    self.tool_id = Some(tool_id);
  }

  pub fn with_tool_id(mut self, tool_id: i32) -> AlertResponse {
    self.tool_id = Some(tool_id);
    self
  }

  pub fn tool_id(&self) -> Option<&i32> {
    self.tool_id.as_ref()
  }

  pub fn reset_tool_id(&mut self) {
    self.tool_id = None;
  }

}



