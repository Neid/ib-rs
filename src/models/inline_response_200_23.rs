/* 
 * Client Portal Web API
 *
 * Client Poral Web API
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct InlineResponse20023 {
  /// Allowed to sell shares that you own
  #[serde(rename = "allow_sell_long")]
  allow_sell_long: Option<bool>,
  /// Classification of Financial Instrument codes
  #[serde(rename = "cfi_code")]
  cfi_code: Option<String>,
  #[serde(rename = "classifier")]
  classifier: Option<String>,
  /// Contracts company name
  #[serde(rename = "company_name")]
  company_name: Option<String>,
  /// IBKRs contract identifier
  #[serde(rename = "con_id")]
  con_id: Option<f32>,
  /// Month the contract must be satisfied by making or accepting delivery
  #[serde(rename = "contract_month")]
  contract_month: Option<String>,
  /// Currency contract trades in
  #[serde(rename = "currency")]
  currency: Option<String>,
  #[serde(rename = "cusip")]
  cusip: Option<String>,
  /// Primary Exchange, Routing or Trading Venue
  #[serde(rename = "exchange")]
  exchange: Option<String>,
  /// Expiration Date in the format YYYYMMDD
  #[serde(rename = "expiry_full")]
  expiry_full: Option<f32>,
  /// Specific group of companies or businesses.
  #[serde(rename = "industry")]
  industry: Option<String>,
  /// Asset Class of the contract
  #[serde(rename = "instrument_type")]
  instrument_type: Option<String>,
  /// Supports zero commission trades
  #[serde(rename = "is_zero_commission_security")]
  is_zero_commission_security: Option<bool>,
  /// Contracts symbol from primary exchange. For options it is the OCC symbol.
  #[serde(rename = "local_symbol")]
  local_symbol: Option<String>,
  /// Date on which the underlying transaction settles if the option is exercised
  #[serde(rename = "maturity_date")]
  maturity_date: Option<f32>,
  /// numerical value of each point of price movement
  #[serde(rename = "multiplier")]
  multiplier: Option<String>,
  /// Provides trading outside of Regular Trading Hours
  #[serde(rename = "r_t_h")]
  r_t_h: Option<bool>,
  /// Put or Call of the option
  #[serde(rename = "right")]
  right: Option<String>,
  #[serde(rename = "rules")]
  rules: Option<Vec<::models::InlineResponse20023Rules>>,
  /// Support IBKRs SMART routing
  #[serde(rename = "smart_available")]
  smart_available: Option<bool>,
  /// fixed price at which the owner of the option buys or sells the underlying
  #[serde(rename = "strike")]
  strike: Option<String>,
  /// Underlying symbol
  #[serde(rename = "symbol")]
  symbol: Option<String>,
  /// Formatted contract parameters
  #[serde(rename = "text")]
  text: Option<String>,
  /// Designation of the contract
  #[serde(rename = "trading_class")]
  trading_class: Option<String>,
  /// IBKRs contract identifier for the underlying instrument
  #[serde(rename = "underlying_con_id")]
  underlying_con_id: Option<f32>,
  /// Legal entity for underlying contract
  #[serde(rename = "underlying_issuer")]
  underlying_issuer: Option<String>,
  /// Comma separated list of exchanges or trading venues
  #[serde(rename = "valid_exchanges")]
  valid_exchanges: Option<String>
}

impl InlineResponse20023 {
  pub fn new() -> InlineResponse20023 {
    InlineResponse20023 {
      allow_sell_long: None,
      cfi_code: None,
      classifier: None,
      company_name: None,
      con_id: None,
      contract_month: None,
      currency: None,
      cusip: None,
      exchange: None,
      expiry_full: None,
      industry: None,
      instrument_type: None,
      is_zero_commission_security: None,
      local_symbol: None,
      maturity_date: None,
      multiplier: None,
      r_t_h: None,
      right: None,
      rules: None,
      smart_available: None,
      strike: None,
      symbol: None,
      text: None,
      trading_class: None,
      underlying_con_id: None,
      underlying_issuer: None,
      valid_exchanges: None
    }
  }

  pub fn set_allow_sell_long(&mut self, allow_sell_long: bool) {
    self.allow_sell_long = Some(allow_sell_long);
  }

  pub fn with_allow_sell_long(mut self, allow_sell_long: bool) -> InlineResponse20023 {
    self.allow_sell_long = Some(allow_sell_long);
    self
  }

  pub fn allow_sell_long(&self) -> Option<&bool> {
    self.allow_sell_long.as_ref()
  }

  pub fn reset_allow_sell_long(&mut self) {
    self.allow_sell_long = None;
  }

  pub fn set_cfi_code(&mut self, cfi_code: String) {
    self.cfi_code = Some(cfi_code);
  }

  pub fn with_cfi_code(mut self, cfi_code: String) -> InlineResponse20023 {
    self.cfi_code = Some(cfi_code);
    self
  }

  pub fn cfi_code(&self) -> Option<&String> {
    self.cfi_code.as_ref()
  }

  pub fn reset_cfi_code(&mut self) {
    self.cfi_code = None;
  }

  pub fn set_classifier(&mut self, classifier: String) {
    self.classifier = Some(classifier);
  }

  pub fn with_classifier(mut self, classifier: String) -> InlineResponse20023 {
    self.classifier = Some(classifier);
    self
  }

  pub fn classifier(&self) -> Option<&String> {
    self.classifier.as_ref()
  }

  pub fn reset_classifier(&mut self) {
    self.classifier = None;
  }

  pub fn set_company_name(&mut self, company_name: String) {
    self.company_name = Some(company_name);
  }

  pub fn with_company_name(mut self, company_name: String) -> InlineResponse20023 {
    self.company_name = Some(company_name);
    self
  }

  pub fn company_name(&self) -> Option<&String> {
    self.company_name.as_ref()
  }

  pub fn reset_company_name(&mut self) {
    self.company_name = None;
  }

  pub fn set_con_id(&mut self, con_id: f32) {
    self.con_id = Some(con_id);
  }

  pub fn with_con_id(mut self, con_id: f32) -> InlineResponse20023 {
    self.con_id = Some(con_id);
    self
  }

  pub fn con_id(&self) -> Option<&f32> {
    self.con_id.as_ref()
  }

  pub fn reset_con_id(&mut self) {
    self.con_id = None;
  }

  pub fn set_contract_month(&mut self, contract_month: String) {
    self.contract_month = Some(contract_month);
  }

  pub fn with_contract_month(mut self, contract_month: String) -> InlineResponse20023 {
    self.contract_month = Some(contract_month);
    self
  }

  pub fn contract_month(&self) -> Option<&String> {
    self.contract_month.as_ref()
  }

  pub fn reset_contract_month(&mut self) {
    self.contract_month = None;
  }

  pub fn set_currency(&mut self, currency: String) {
    self.currency = Some(currency);
  }

  pub fn with_currency(mut self, currency: String) -> InlineResponse20023 {
    self.currency = Some(currency);
    self
  }

  pub fn currency(&self) -> Option<&String> {
    self.currency.as_ref()
  }

  pub fn reset_currency(&mut self) {
    self.currency = None;
  }

  pub fn set_cusip(&mut self, cusip: String) {
    self.cusip = Some(cusip);
  }

  pub fn with_cusip(mut self, cusip: String) -> InlineResponse20023 {
    self.cusip = Some(cusip);
    self
  }

  pub fn cusip(&self) -> Option<&String> {
    self.cusip.as_ref()
  }

  pub fn reset_cusip(&mut self) {
    self.cusip = None;
  }

  pub fn set_exchange(&mut self, exchange: String) {
    self.exchange = Some(exchange);
  }

  pub fn with_exchange(mut self, exchange: String) -> InlineResponse20023 {
    self.exchange = Some(exchange);
    self
  }

  pub fn exchange(&self) -> Option<&String> {
    self.exchange.as_ref()
  }

  pub fn reset_exchange(&mut self) {
    self.exchange = None;
  }

  pub fn set_expiry_full(&mut self, expiry_full: f32) {
    self.expiry_full = Some(expiry_full);
  }

  pub fn with_expiry_full(mut self, expiry_full: f32) -> InlineResponse20023 {
    self.expiry_full = Some(expiry_full);
    self
  }

  pub fn expiry_full(&self) -> Option<&f32> {
    self.expiry_full.as_ref()
  }

  pub fn reset_expiry_full(&mut self) {
    self.expiry_full = None;
  }

  pub fn set_industry(&mut self, industry: String) {
    self.industry = Some(industry);
  }

  pub fn with_industry(mut self, industry: String) -> InlineResponse20023 {
    self.industry = Some(industry);
    self
  }

  pub fn industry(&self) -> Option<&String> {
    self.industry.as_ref()
  }

  pub fn reset_industry(&mut self) {
    self.industry = None;
  }

  pub fn set_instrument_type(&mut self, instrument_type: String) {
    self.instrument_type = Some(instrument_type);
  }

  pub fn with_instrument_type(mut self, instrument_type: String) -> InlineResponse20023 {
    self.instrument_type = Some(instrument_type);
    self
  }

  pub fn instrument_type(&self) -> Option<&String> {
    self.instrument_type.as_ref()
  }

  pub fn reset_instrument_type(&mut self) {
    self.instrument_type = None;
  }

  pub fn set_is_zero_commission_security(&mut self, is_zero_commission_security: bool) {
    self.is_zero_commission_security = Some(is_zero_commission_security);
  }

  pub fn with_is_zero_commission_security(mut self, is_zero_commission_security: bool) -> InlineResponse20023 {
    self.is_zero_commission_security = Some(is_zero_commission_security);
    self
  }

  pub fn is_zero_commission_security(&self) -> Option<&bool> {
    self.is_zero_commission_security.as_ref()
  }

  pub fn reset_is_zero_commission_security(&mut self) {
    self.is_zero_commission_security = None;
  }

  pub fn set_local_symbol(&mut self, local_symbol: String) {
    self.local_symbol = Some(local_symbol);
  }

  pub fn with_local_symbol(mut self, local_symbol: String) -> InlineResponse20023 {
    self.local_symbol = Some(local_symbol);
    self
  }

  pub fn local_symbol(&self) -> Option<&String> {
    self.local_symbol.as_ref()
  }

  pub fn reset_local_symbol(&mut self) {
    self.local_symbol = None;
  }

  pub fn set_maturity_date(&mut self, maturity_date: f32) {
    self.maturity_date = Some(maturity_date);
  }

  pub fn with_maturity_date(mut self, maturity_date: f32) -> InlineResponse20023 {
    self.maturity_date = Some(maturity_date);
    self
  }

  pub fn maturity_date(&self) -> Option<&f32> {
    self.maturity_date.as_ref()
  }

  pub fn reset_maturity_date(&mut self) {
    self.maturity_date = None;
  }

  pub fn set_multiplier(&mut self, multiplier: String) {
    self.multiplier = Some(multiplier);
  }

  pub fn with_multiplier(mut self, multiplier: String) -> InlineResponse20023 {
    self.multiplier = Some(multiplier);
    self
  }

  pub fn multiplier(&self) -> Option<&String> {
    self.multiplier.as_ref()
  }

  pub fn reset_multiplier(&mut self) {
    self.multiplier = None;
  }

  pub fn set_r_t_h(&mut self, r_t_h: bool) {
    self.r_t_h = Some(r_t_h);
  }

  pub fn with_r_t_h(mut self, r_t_h: bool) -> InlineResponse20023 {
    self.r_t_h = Some(r_t_h);
    self
  }

  pub fn r_t_h(&self) -> Option<&bool> {
    self.r_t_h.as_ref()
  }

  pub fn reset_r_t_h(&mut self) {
    self.r_t_h = None;
  }

  pub fn set_right(&mut self, right: String) {
    self.right = Some(right);
  }

  pub fn with_right(mut self, right: String) -> InlineResponse20023 {
    self.right = Some(right);
    self
  }

  pub fn right(&self) -> Option<&String> {
    self.right.as_ref()
  }

  pub fn reset_right(&mut self) {
    self.right = None;
  }

  pub fn set_rules(&mut self, rules: Vec<::models::InlineResponse20023Rules>) {
    self.rules = Some(rules);
  }

  pub fn with_rules(mut self, rules: Vec<::models::InlineResponse20023Rules>) -> InlineResponse20023 {
    self.rules = Some(rules);
    self
  }

  pub fn rules(&self) -> Option<&Vec<::models::InlineResponse20023Rules>> {
    self.rules.as_ref()
  }

  pub fn reset_rules(&mut self) {
    self.rules = None;
  }

  pub fn set_smart_available(&mut self, smart_available: bool) {
    self.smart_available = Some(smart_available);
  }

  pub fn with_smart_available(mut self, smart_available: bool) -> InlineResponse20023 {
    self.smart_available = Some(smart_available);
    self
  }

  pub fn smart_available(&self) -> Option<&bool> {
    self.smart_available.as_ref()
  }

  pub fn reset_smart_available(&mut self) {
    self.smart_available = None;
  }

  pub fn set_strike(&mut self, strike: String) {
    self.strike = Some(strike);
  }

  pub fn with_strike(mut self, strike: String) -> InlineResponse20023 {
    self.strike = Some(strike);
    self
  }

  pub fn strike(&self) -> Option<&String> {
    self.strike.as_ref()
  }

  pub fn reset_strike(&mut self) {
    self.strike = None;
  }

  pub fn set_symbol(&mut self, symbol: String) {
    self.symbol = Some(symbol);
  }

  pub fn with_symbol(mut self, symbol: String) -> InlineResponse20023 {
    self.symbol = Some(symbol);
    self
  }

  pub fn symbol(&self) -> Option<&String> {
    self.symbol.as_ref()
  }

  pub fn reset_symbol(&mut self) {
    self.symbol = None;
  }

  pub fn set_text(&mut self, text: String) {
    self.text = Some(text);
  }

  pub fn with_text(mut self, text: String) -> InlineResponse20023 {
    self.text = Some(text);
    self
  }

  pub fn text(&self) -> Option<&String> {
    self.text.as_ref()
  }

  pub fn reset_text(&mut self) {
    self.text = None;
  }

  pub fn set_trading_class(&mut self, trading_class: String) {
    self.trading_class = Some(trading_class);
  }

  pub fn with_trading_class(mut self, trading_class: String) -> InlineResponse20023 {
    self.trading_class = Some(trading_class);
    self
  }

  pub fn trading_class(&self) -> Option<&String> {
    self.trading_class.as_ref()
  }

  pub fn reset_trading_class(&mut self) {
    self.trading_class = None;
  }

  pub fn set_underlying_con_id(&mut self, underlying_con_id: f32) {
    self.underlying_con_id = Some(underlying_con_id);
  }

  pub fn with_underlying_con_id(mut self, underlying_con_id: f32) -> InlineResponse20023 {
    self.underlying_con_id = Some(underlying_con_id);
    self
  }

  pub fn underlying_con_id(&self) -> Option<&f32> {
    self.underlying_con_id.as_ref()
  }

  pub fn reset_underlying_con_id(&mut self) {
    self.underlying_con_id = None;
  }

  pub fn set_underlying_issuer(&mut self, underlying_issuer: String) {
    self.underlying_issuer = Some(underlying_issuer);
  }

  pub fn with_underlying_issuer(mut self, underlying_issuer: String) -> InlineResponse20023 {
    self.underlying_issuer = Some(underlying_issuer);
    self
  }

  pub fn underlying_issuer(&self) -> Option<&String> {
    self.underlying_issuer.as_ref()
  }

  pub fn reset_underlying_issuer(&mut self) {
    self.underlying_issuer = None;
  }

  pub fn set_valid_exchanges(&mut self, valid_exchanges: String) {
    self.valid_exchanges = Some(valid_exchanges);
  }

  pub fn with_valid_exchanges(mut self, valid_exchanges: String) -> InlineResponse20023 {
    self.valid_exchanges = Some(valid_exchanges);
    self
  }

  pub fn valid_exchanges(&self) -> Option<&String> {
    self.valid_exchanges.as_ref()
  }

  pub fn reset_valid_exchanges(&mut self) {
    self.valid_exchanges = None;
  }

}



